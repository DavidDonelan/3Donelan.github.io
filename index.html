<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Wave Simulation - Point Editor</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
overflow: hidden;
background: #000;
}
#canvas {
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background: #000;
cursor: crosshair;
touch-action: none;
}

/* Long press indicator */
.long-press-indicator {
position: fixed;
pointer-events: none;
width: 60px;
height: 60px;
border: 2px solid rgba(0, 255, 136, 0.6);
border-radius: 50%;
opacity: 0;
transform: translate(-50%, -50%) scale(0.5);
transition: none;
z-index: 1000;
}

.long-press-indicator.active {
animation: longPressGrow 0.5s ease-out forwards;
}

@keyframes longPressGrow {
0% {
opacity: 1;
transform: translate(-50%, -50%) scale(0.5);
border-width: 2px;
}
100% {
opacity: 1;
transform: translate(-50%, -50%) scale(1.2);
border-width: 3px;
border-color: rgba(0, 255, 136, 1);
box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
}
}

.long-press-indicator.complete {
animation: longPressComplete 0.3s ease-out forwards;
}

@keyframes longPressComplete {
0% {
opacity: 1;
transform: translate(-50%, -50%) scale(1.2);
}
100% {
opacity: 0;
transform: translate(-50%, -50%) scale(1.5);
}
}

/* Clone flash effect */
@keyframes cloneFlash {
    0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
    }
    50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.5);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(2);
    }
}

.clone-flash {
    position: fixed;
    pointer-events: none;
    width: 80px;
    height: 80px;
    border: 3px solid rgba(0, 136, 255, 0.8);
    border-radius: 50%;
    opacity: 0;
    transform: translate(-50%, -50%);
    z-index: 1001;
    animation: cloneFlash 0.5s ease-out;
}

.menu-toggle {
position: fixed;
top: 20px;
right: 20px;
z-index: 1000;
width: 50px;
height: 50px;
background: rgba(255, 255, 255, 0.1);
backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.2);
border-radius: 50%;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
transition: all 0.3s ease;
}
.menu-toggle:hover {
background: rgba(255, 255, 255, 0.2);
}
.menu-icon {
width: 24px;
height: 18px;
position: relative;
}
.menu-icon span {
display: block;
width: 100%;
height: 2px;
background: white;
margin: 4px 0;
transition: 0.3s;
}
.menu-toggle.active .menu-icon span:nth-child(1) {
transform: rotate(45deg) translate(5px, 5px);
}
.menu-toggle.active .menu-icon span:nth-child(2) {
opacity: 0;
}
.menu-toggle.active .menu-icon span:nth-child(3) {
transform: rotate(-45deg) translate(7px, -6px);
}
.control-panel {
position: fixed;
top: 0;
right: -360px;
width: 360px;
height: 100vh;
background: rgba(20, 20, 20, 0.95);
backdrop-filter: blur(20px);
border-left: 1px solid rgba(255, 255, 255, 0.1);
z-index: 999;
transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
overflow-y: auto;
color: white;
}
.control-panel.open {
right: 0;
}
.panel-header {
padding: 20px;
border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
.panel-title {
font-size: 18px;
font-weight: 600;
margin-bottom: 5px;
}
.panel-subtitle {
font-size: 12px;
opacity: 0.7;
}
.control-section {
padding: 20px;
border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}
.section-title {
font-size: 14px;
font-weight: 500;
margin-bottom: 15px;
opacity: 0.9;
}
.control-group {
margin-bottom: 20px;
}
.control-label {
display: block;
font-size: 12px;
margin-bottom: 8px;
opacity: 0.8;
}
.slider-container {
position: relative;
}
.slider {
width: 100%;
height: 6px;
background: rgba(255, 255, 255, 0.1);
border-radius: 3px;
outline: none;
appearance: none;
-webkit-appearance: none;
}
.slider::-webkit-slider-thumb {
appearance: none;
-webkit-appearance: none;
width: 20px;
height: 20px;
background: white;
border-radius: 50%;
cursor: pointer;
box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}
.slider::-moz-range-thumb {
width: 20px;
height: 20px;
background: white;
border-radius: 50%;
cursor: pointer;
border: none;
box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}
.slider-value {
position: absolute;
right: 0;
top: -25px;
font-size: 11px;
background: rgba(255, 255, 255, 0.1);
padding: 2px 6px;
border-radius: 3px;
min-width: 35px;
text-align: center;
}
.button-group {
display: flex;
gap: 10px;
flex-wrap: wrap;
}
.control-button {
flex: 1;
min-width: 80px;
padding: 12px 16px;
background: rgba(255, 255, 255, 0.1);
border: 1px solid rgba(255, 255, 255, 0.2);
border-radius: 8px;
color: white;
font-size: 13px;
cursor: pointer;
transition: all 0.2s ease;
}
.control-button:hover {
background: rgba(255, 255, 255, 0.2);
}
.control-button:active {
transform: scale(0.98);
}
.control-button.active {
background: rgba(255, 255, 255, 0.3);
border-color: rgba(255, 255, 255, 0.5);
}
.control-button.delete {
background: rgba(255, 68, 68, 0.2);
border-color: rgba(255, 68, 68, 0.4);
}
.control-button.delete:hover {
background: rgba(255, 68, 68, 0.3);
}
.stats-display {
font-size: 11px;
opacity: 0.6;
margin-top: 10px;
}
.performance-info {
font-size: 10px;
opacity: 0.5;
margin-top: 5px;
font-family: monospace;
}
.point-section {
background: rgba(255, 255, 255, 0.05);
border-radius: 8px;
padding: 15px;
margin-bottom: 15px;
}
.point-header {
display: flex;
justify-content: between;
align-items: center;
margin-bottom: 15px;
}
.point-id {
font-size: 12px;
opacity: 0.7;
font-family: monospace;
}
.no-selection {
text-align: center;
opacity: 0.5;
font-size: 12px;
padding: 20px;
}
.point-list {
max-height: 200px;
overflow-y: auto;
border: 1px solid rgba(255, 255, 255, 0.1);
border-radius: 5px;
}
.point-item {
padding: 8px 12px;
border-bottom: 1px solid rgba(255, 255, 255, 0.05);
cursor: pointer;
transition: background 0.2s;
font-size: 12px;
}
.point-item:hover {
background: rgba(255, 255, 255, 0.1);
}
.point-item.selected {
background: rgba(255, 255, 255, 0.2);
}
.panel-overlay {
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background: rgba(0, 0, 0, 0.3);
z-index: 998;
opacity: 0;
visibility: hidden;
transition: all 0.3s ease;
}
.panel-overlay.active {
opacity: 1;
visibility: visible;
}
.welcome-overlay {
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background: rgba(0, 0, 0, 0.8);
backdrop-filter: blur(10px);
z-index: 2000;
display: flex;
align-items: center;
justify-content: center;
padding: 20px;
}
.welcome-modal {
background: rgba(20, 20, 20, 0.95);
backdrop-filter: blur(20px);
border: 1px solid rgba(255, 255, 255, 0.2);
border-radius: 16px;
max-width: 500px;
width: 100%;
color: white;
overflow: hidden;
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
}
.welcome-header {
padding: 30px 30px 20px;
text-align: center;
border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
.welcome-header h2 {
font-size: 24px;
font-weight: 600;
margin-bottom: 8px;
color: white;
}
.welcome-header p {
font-size: 14px;
opacity: 0.7;
margin: 0;
}
.welcome-content {
padding: 25px 30px;
}
.instruction-list {
display: flex;
flex-direction: column;
gap: 16px;
}
.instruction-item {
font-size: 14px;
line-height: 1.5;
padding: 12px 16px;
background: rgba(255, 255, 255, 0.05);
border-radius: 8px;
border-left: 3px solid rgba(255, 255, 255, 0.3);
}
.instruction-item strong {
color: #00ff88;
font-weight: 600;
}
.welcome-footer {
padding: 20px 30px 30px;
text-align: center;
}
.welcome-button {
background: linear-gradient(135deg, #00ff88, #00cc6a);
border: none;
border-radius: 12px;
color: white;
font-size: 16px;
font-weight: 600;
padding: 16px 32px;
cursor: pointer;
transition: all 0.3s ease;
box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
}
.welcome-button:hover {
transform: translateY(-2px);
box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
}
.welcome-button:active {
transform: translateY(0);
}
@media (min-width: 768px) {
.menu-toggle {
top: 30px;
right: 30px;
width: 60px;
height: 60px;
}
.control-panel {
width: 400px;
right: -400px;
}
.control-section {
padding: 25px;
}
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<!-- Long press indicator -->
<div class="long-press-indicator" id="longPressIndicator"></div>

<!-- Welcome Modal -->
<div class="welcome-overlay" id="welcomeOverlay">
<div class="welcome-modal">
<div class="welcome-header">
<h2>Wave Physics Simulation</h2>
<p>Interactive wave interference patterns</p>
</div>
<div class="welcome-content">
<div class="instruction-list">
<div class="instruction-item">
<strong>Create waves:</strong> Press and hold on empty space to add wave sources
</div>
<div class="instruction-item">
<strong>Select & move:</strong> Tap a point to select, then drag to reposition
</div>
<div class="instruction-item">
<strong>Animate points:</strong> Set velocity to make points move and bounce
</div>
<div class="instruction-item">
<strong>Customize:</strong> Use the menu (top-right) to adjust wave properties
</div>
</div>
</div>
<div class="welcome-footer">
<button class="welcome-button" id="welcomeStartBtn">Get Started</button>
</div>
</div>
</div>

<button class="menu-toggle" id="menuToggle">
<div class="menu-icon">
<span></span>
<span></span>
<span></span>
</div>
</button>

<div class="panel-overlay" id="panelOverlay"></div>
<div class="control-panel" id="controlPanel">
<div class="panel-header">
<div class="panel-title">Wave Point Editor</div>
<div class="panel-subtitle">Press and hold on canvas to add points</div>
</div>
<div class="control-section">
<div class="section-title">Animation</div>
<div class="button-group">
<button class="control-button" id="clearBtn">Clear All</button>
<button class="control-button" id="playPauseBtn">Pause</button>
<button class="control-button" id="syncBtn">Sync</button>
</div>
<div class="button-group" style="margin-top: 10px;">
<button class="control-button" id="showPointsBtn">Show Points</button>
<button class="control-button" id="animatePointsBtn">Animate Points</button>
</div>
<div class="stats-display" id="stats">Points: 0</div>
</div>
<div class="control-section">
<div class="section-title">Point List</div>
<div class="point-list" id="pointList">
<div class="no-selection">No points created</div>
</div>
</div>
<div class="control-section" id="selectedPointSection" style="display: none;">
<div class="section-title">Selected Point</div>
<div class="point-section">
<div class="point-header">
<span class="point-id" id="selectedPointId">Point #1</span>
</div>
<div class="control-group">
<label class="control-label">Wave Type</label>
<div class="button-group">
<button class="control-button active" id="pointWaveTypeBtn">Sine</button>
</div>
</div>
<div class="control-group">
<label class="control-label">Strength</label>
<div class="slider-container">
<input type="range" class="slider" id="pointStrengthSlider"
min="10" max="100" step="5" value="60">
<div class="slider-value" id="pointStrengthValue">60</div>
</div>
</div>
<div class="control-group">
<label class="control-label">Frequency</label>
<div class="slider-container">
<input type="range" class="slider" id="pointFrequencySlider"
min="0.005" max="0.08" step="0.005" value="0.02">
<div class="slider-value" id="pointFrequencyValue">0.020</div>
</div>
</div>
<div class="control-group">
<label class="control-label">Speed</label>
<div class="slider-container">
<input type="range" class="slider" id="pointSpeedSlider"
min="0.1" max="1.0" step="0.1" value="1.0">
<div class="slider-value" id="pointSpeedValue">1.0</div>
</div>
</div>
<div class="control-group">
<label class="control-label">Velocity</label>
<div class="slider-container">
<input type="range" class="slider" id="pointVelocitySlider"
min="0" max="50" step="5" value="0">
<div class="slider-value" id="pointVelocityValue">0</div>
</div>
</div>
<div class="button-group">
<button class="control-button delete" id="deletePointBtn">Delete Point</button>
</div>
</div>
</div>
<div class="control-section">
<div class="section-title">Medium Properties</div>
<div class="control-group">
<label class="control-label">Wave Fade</label>
<div class="slider-container">
<input type="range" class="slider" id="fadeSlider"
min="0.0" max="0.03" step="0.002" value="0.008">
<div class="slider-value" id="fadeValue">0.008</div>
</div>
</div>
</div>
<div class="control-section">
<div class="section-title">Color Settings</div>
<div class="control-group">
<label class="control-label">Color Mode</label>
<div class="button-group">
<button class="control-button active" id="colorModeBtn">Grayscale</button>
</div>
</div>
<div class="control-group" id="colorControls" style="display: none;">
<label class="control-label">Minima Color (Hue)</label>
<div class="slider-container">
<input type="range" class="slider" id="hue1Slider"
min="0" max="360" step="1" value="240">
<div class="slider-value" id="hue1Value">240°</div>
</div>
</div>
<div class="control-group" id="colorControls2" style="display: none;">
<label class="control-label">Maxima Color (Hue)</label>
<div class="slider-container">
<input type="range" class="slider" id="hue2Slider"
min="0" max="360" step="1" value="0">
<div class="slider-value" id="hue2Value">0°</div>
</div>
</div>
<div class="button-group" id="colorButtons" style="display: none;">
<button class="control-button" id="complementaryBtn">Complementary</button>
</div>
<div class="control-group" id="colorPreview" style="display: none;">
<label class="control-label">Color Preview</label>
<div id="gradientPreview" style="
width: 100%;
height: 20px;
border-radius: 4px;
background: linear-gradient(to right, hsl(240, 70%, 50%), hsl(0, 70%, 50%));
border: 1px solid rgba(255, 255, 255, 0.2);
"></div>
</div>
</div>
<div class="control-section">
<div class="section-title">Performance</div>
<div class="control-group">
<label class="control-label">Resolution</label>
<div class="slider-container">
<input type="range" class="slider" id="performanceSlider"
min="0" max="5" step="1" value="1">
<div class="slider-value" id="performanceValue">Balanced</div>
</div>
<div class="performance-info" id="performanceInfo">
Resolution: calculating...
</div>
</div>
<div class="control-group">
<label class="control-label">Frame Rate</label>
<div class="slider-container">
<input type="range" class="slider" id="fpsSlider"
min="15" max="60" step="15" value="30">
<div class="slider-value" id="fpsValue">30 FPS</div>
</div>
</div>
</div>
</div>

<script>
'use strict';

// ===== CONFIGURATION =====
const CONFIG = Object.freeze({
wave: { maxAmplitude: 100, timeStep: 0.2 },
performance: {
levels: [
{ skip: 1, label: 'Quality' },
{ skip: 2, label: 'Balanced' },
{ skip: 4, label: 'Fast' },
{ skip: 8, label: 'Faster' },
{ skip: 16, label: 'Very Fast' },
{ skip: 32, label: 'Ultra Fast' }
],
default: 1
},
defaults: {
strength: 60, frequency: 0.02, speed: 1.0,
waveType: 'sine', velocity: 0
},
colors: {
hue1: 240, hue2: 0, saturation: 70,
lightness: 50, useColor: false
},
medium: { fade: 0.008 },
interaction: {
pointRadius: 20, 
visualRadius: 6, 
dragThreshold: 5,
longPressTime: 500,  // milliseconds for long press
moveThreshold: 10,    // pixels - if moved more than this, cancel long press
},
animation: { targetFPS: 30, minFPS: 15, maxFPS: 60 }
});

// ===== UTILITIES =====
const Utils = {
clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
formatValue: (val, decimals = 3) => Number(val).toFixed(decimals),
distance: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
generateId: () => `point_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
lerpHue: (hue1, hue2, t) => {
let diff = Math.abs(hue1 - hue2);
if (diff > 180) {
if (hue2 > hue1) hue1 += 360;
else hue2 += 360;
}
return Math.round((hue1 + (hue2 - hue1) * t) % 360);
},
hslToRgb: (h, s, l) => {
h /= 360; s /= 100; l /= 100;
const c = (1 - Math.abs(2 * l - 1)) * s;
const x = c * (1 - Math.abs((h * 6) % 2 - 1));
const m = l - c / 2;
let r, g, b;
if (h < 1/6) [r, g, b] = [c, x, 0];
else if (h < 2/6) [r, g, b] = [x, c, 0];
else if (h < 3/6) [r, g, b] = [0, c, x];
else if (h < 4/6) [r, g, b] = [0, x, c];
else if (h < 5/6) [r, g, b] = [x, 0, c];
else [r, g, b] = [c, 0, x];
return {
r: Math.round((r + m) * 255),
g: Math.round((g + m) * 255),
b: Math.round((b + m) * 255)
};
},
// Haptic feedback support
triggerHaptic: () => {
if ('vibrate' in navigator) {
navigator.vibrate(10);  // Short vibration
}
}
};

// ===== EVENT SYSTEM =====
class EventEmitter {
constructor() { this.listeners = new Map(); }
on(event, callback) {
if (!this.listeners.has(event)) this.listeners.set(event, []);
this.listeners.get(event).push(callback);
}
emit(event, data) {
const callbacks = this.listeners.get(event);
if (callbacks) callbacks.forEach(cb => cb(data));
}
}

// ===== PHYSICS ENGINE =====
class Physics {
static updatePosition(point, deltaTime, bounds) {
if (point.velocity === 0) return;
point.x += point.vx * deltaTime;
point.y += point.vy * deltaTime;
const margin = CONFIG.interaction.visualRadius;
if (point.x <= margin) {
point.x = margin;
point.vx = Math.abs(point.vx);
} else if (point.x >= bounds.width - margin) {
point.x = bounds.width - margin;
point.vx = -Math.abs(point.vx);
}
if (point.y <= margin) {
point.y = margin;
point.vy = Math.abs(point.vy);
} else if (point.y >= bounds.height - margin) {
point.y = bounds.height - margin;
point.vy = -Math.abs(point.vy);
}
}
static setRandomVelocity(point, speed) {
if (speed > 0) {
const angle = Math.random() * 2 * Math.PI;
point.vx = Math.cos(angle) * speed;
point.vy = Math.sin(angle) * speed;
} else {
point.vx = point.vy = 0;
}
}
}

// ===== WAVE MATHEMATICS =====
class WaveMath {
static sine(phase, amplitude) { return amplitude * Math.sin(phase); }
static step(phase, amplitude) {
const normalized = ((phase % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
return amplitude * (normalized < Math.PI ? 1 : -1);
}
static applyFade(value, distance, fadeRate) {
return value * Math.exp(-distance * fadeRate);
}
static toColor(waveValue, colorSettings) {
if (!colorSettings.useColor) {
const normalized = waveValue / CONFIG.wave.maxAmplitude;
return Utils.clamp(128 + normalized * 127, 0, 255);
}
const normalizedValue = Utils.clamp((waveValue / CONFIG.wave.maxAmplitude + 1) / 2, 0, 1);
const interpolatedHue = Utils.lerpHue(colorSettings.hue1, colorSettings.hue2, normalizedValue);
return Utils.hslToRgb(interpolatedHue, colorSettings.saturation, colorSettings.lightness);
}
}

// ===== WAVE POINT =====
class WavePoint {
constructor(x, y, properties = {}) {
this.id = Utils.generateId();
this.x = x;
this.y = y;
this.startTime = 0;
this.selected = false;
this.vx = 0;
this.vy = 0;
Object.assign(this, CONFIG.defaults, properties);
if (this.velocity > 0) Physics.setRandomVelocity(this, this.velocity);
}
updateVelocity(newVelocity) {
const oldVelocity = this.velocity;
this.velocity = newVelocity;
if (newVelocity === 0) {
this.vx = this.vy = 0;
} else if (oldVelocity === 0) {
Physics.setRandomVelocity(this, newVelocity);
} else {
const scale = newVelocity / oldVelocity;
this.vx *= scale;
this.vy *= scale;
}
}
updatePosition(deltaTime, bounds) {
Physics.updatePosition(this, deltaTime, bounds);
}
setStartTime(time) { this.startTime = time; }
getAge(currentTime) { return currentTime - this.startTime; }
distanceTo(x, y) { return Utils.distance(this.x, this.y, x, y); }
isHit(x, y) { return this.distanceTo(x, y) <= CONFIG.interaction.pointRadius; }
updateProperty(key, value) {
if (key === 'velocity') {
this.updateVelocity(value);
return true;
} else if (key in this && !['id', 'x', 'y', 'startTime', 'vx', 'vy'].includes(key)) {
this[key] = value;
return true;
}
return false;
}
getDisplayName() { return `Point ${this.id.split('_')[1].slice(-3)}`; }
}

// ===== POINT MANAGER =====
class PointManager extends EventEmitter {
constructor() {
super();
this.points = new Map();
this.selectedId = null;
}
add(x, y, properties = {}) {
const point = new WavePoint(x, y, properties);
this.points.set(point.id, point);
this.emit('pointAdded', point);
return point;
}
remove(id) {
if (this.selectedId === id) this.selectedId = null;
const removed = this.points.delete(id);
if (removed) this.emit('pointRemoved', id);
return removed;
}
clear() {
this.points.clear();
this.selectedId = null;
this.emit('pointsCleared');
}
select(id) {
if (!this.points.has(id)) return null;
if (this.selectedId) {
const prev = this.points.get(this.selectedId);
if (prev) prev.selected = false;
}
this.selectedId = id;
const point = this.points.get(id);
point.selected = true;
this.emit('pointSelected', point);
return point;
}
deselect() {
if (this.selectedId) {
const point = this.points.get(this.selectedId);
if (point) point.selected = false;
this.selectedId = null;
this.emit('pointDeselected');
}
}
getSelected() { return this.selectedId ? this.points.get(this.selectedId) : null; }
findPointAt(x, y) {
for (const point of this.points.values()) {
if (point.isHit(x, y)) return point;
}
return null;
}
updatePositions(deltaTime, bounds) {
for (const point of this.points.values()) {
point.updatePosition(deltaTime, bounds);
}
}
get count() { return this.points.size; }
forEach(callback) { this.points.forEach(callback); }
[Symbol.iterator]() { return this.points.values(); }
getAllPoints() { return Array.from(this.points.values()); }
}

// ===== APPLICATION STATE =====
class AppState extends EventEmitter {
constructor() {
super();
this.time = 0;
this.isAnimating = false;
this.showPoints = false;
this.animatePoints = false;
this.mediumFade = CONFIG.medium.fade;
this.targetFPS = CONFIG.animation.targetFPS;
this.frameInterval = 1000 / this.targetFPS;
this.lastFrameTime = 0;
this.performanceLevel = CONFIG.performance.default;
Object.assign(this, CONFIG.colors);
}
setProperty(key, value) {
if (this[key] !== value) {
this[key] = value;
this.emit(`${key}Changed`, value);
}
}
setAnimating(val) { this.setProperty('isAnimating', val); }
setShowPoints(val) { this.setProperty('showPoints', val); }
setAnimatePoints(val) { this.setProperty('animatePoints', val); }
setUseColor(val) { this.setProperty('useColor', val); }
setHue1(val) { this.setProperty('hue1', val); }
setHue2(val) { this.setProperty('hue2', val); }
setMediumFade(val) { this.setProperty('mediumFade', val); }
setPerformanceLevel(val) { this.setProperty('performanceLevel', val); }
setFPS(fps) {
this.targetFPS = Utils.clamp(fps, CONFIG.animation.minFPS, CONFIG.animation.maxFPS);
this.frameInterval = 1000 / this.targetFPS;
this.emit('fpsChanged', this.targetFPS);
}
incrementTime() {
this.time += CONFIG.wave.timeStep;
this.emit('timeChanged', this.time);
}
resetTime() {
this.time = 0;
this.emit('timeChanged', this.time);
}
shouldRender(currentTime) {
return this.isAnimating && (currentTime - this.lastFrameTime) >= this.frameInterval;
}
updateFrameTime(currentTime) { this.lastFrameTime = currentTime; }
getColorSettings() {
return {
useColor: this.useColor, hue1: this.hue1, hue2: this.hue2,
saturation: this.saturation, lightness: this.lightness
};
}
}

// ===== RENDERERS =====
class WaveFieldRenderer {
constructor(canvas) {
this.canvas = canvas;
this.ctx = canvas.getContext('2d');
this.skipFactor = CONFIG.performance.levels[CONFIG.performance.default].skip;
this.resize();
}
resize() {
this.canvas.width = window.innerWidth;
this.canvas.height = window.innerHeight;
this.imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
}
setPerformanceLevel(level) {
this.skipFactor = CONFIG.performance.levels[level].skip;
}
render(points, mediumFade, time, colorSettings) {
this.clearCanvas();
if (points.count > 0) this.renderWaveField(points, mediumFade, time, colorSettings);
this.ctx.putImageData(this.imageData, 0, 0);
}
clearCanvas() {
const data = this.imageData.data;
for (let i = 0; i < data.length; i += 4) {
data[i] = data[i + 1] = data[i + 2] = 0;
data[i + 3] = 255;
}
}
renderWaveField(points, mediumFade, time, colorSettings) {
const { width, height } = this.canvas;
for (let y = 0; y < height; y += this.skipFactor) {
for (let x = 0; x < width; x += this.skipFactor) {
const colorData = this.calculatePixelColor(x, y, points, mediumFade, time, colorSettings);
this.fillPixelBlock(x, y, colorData);
}
}
}
calculatePixelColor(x, y, points, mediumFade, time, colorSettings) {
let totalWave = 0;
for (const point of points) {
const age = point.getAge(time);
if (age < 0) continue;
const distance = point.distanceTo(x, y);
const phase = point.frequency * distance - point.speed * age;
let waveValue = point.waveType === 'sine'
? WaveMath.sine(phase, point.strength)
: WaveMath.step(phase, point.strength);
waveValue = WaveMath.applyFade(waveValue, distance, mediumFade);
totalWave += waveValue;
}
return WaveMath.toColor(totalWave, colorSettings);
}
fillPixelBlock(startX, startY, colorData) {
const data = this.imageData.data;
const { width, height } = this.canvas;
for (let dy = 0; dy < this.skipFactor; dy++) {
for (let dx = 0; dx < this.skipFactor; dx++) {
const x = startX + dx;
const y = startY + dy;
if (x < width && y < height) {
const index = (y * width + x) * 4;
if (typeof colorData === 'object') {
data[index] = colorData.r;
data[index + 1] = colorData.g;
data[index + 2] = colorData.b;
} else {
data[index] = data[index + 1] = data[index + 2] = colorData;
}
}
}
}
}
}

class PointRenderer {
constructor(canvas) {
this.canvas = canvas;
this.ctx = canvas.getContext('2d');
}
render(points, showPoints) {
const selected = points.getSelected();
if (!showPoints) {
if (selected) this.drawPoint(selected, true);
} else {
for (const point of points) {
this.drawPoint(point, point.selected);
}
}
}
drawPoint(point, isSelected) {
const radius = CONFIG.interaction.visualRadius;
const ringRadius = CONFIG.interaction.pointRadius;
if (isSelected) {
this.ctx.strokeStyle = '#00ff88';
this.ctx.lineWidth = 2;
this.ctx.beginPath();
this.ctx.arc(point.x, point.y, ringRadius, 0, 2 * Math.PI);
this.ctx.stroke();
this.ctx.fillStyle = '#00ff88';
} else {
this.ctx.fillStyle = point.velocity > 0 ? '#ff8844' : '#ff4444';
}
this.ctx.beginPath();
this.ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
this.ctx.fill();
}
}

// ===== UI CONTROLLER =====
class UIController {
constructor() {
this.isOpen = false;
this.elements = new Map();
this.initializeElements();
this.setupEventListeners();
}
initializeElements() {
const elementIds = [
'menuToggle', 'panelOverlay', 'controlPanel', 'welcomeOverlay', 'welcomeStartBtn',
'clearBtn', 'playPauseBtn', 'syncBtn', 'showPointsBtn', 'animatePointsBtn',
'pointList', 'selectedPointSection', 'selectedPointId', 'pointWaveTypeBtn',
'pointStrengthSlider', 'pointFrequencySlider', 'pointSpeedSlider', 'pointVelocitySlider',
'deletePointBtn', 'pointStrengthValue', 'pointFrequencyValue', 'pointSpeedValue',
'pointVelocityValue', 'fadeSlider', 'fadeValue', 'performanceSlider',
'performanceValue', 'performanceInfo', 'fpsSlider', 'fpsValue', 'stats',
'colorModeBtn', 'hue1Slider', 'hue2Slider', 'hue1Value', 'hue2Value',
'complementaryBtn', 'gradientPreview', 'colorControls', 'colorControls2',
'colorButtons', 'colorPreview', 'longPressIndicator'
];
elementIds.forEach(id => {
const element = document.getElementById(id);
if (element) this.elements.set(id, element);
});
}
setupEventListeners() {
this.on('menuToggle', 'click', () => this.togglePanel());
this.on('panelOverlay', 'click', () => this.closePanel());
this.on('welcomeStartBtn', 'click', () => this.hideWelcomeModal());
document.addEventListener('keydown', e => {
if (e.key === 'Escape' && this.isOpen) this.closePanel();
});
}
on(elementId, event, handler) {
const element = this.elements.get(elementId);
if (element) element.addEventListener(event, handler);
}
setText(elementId, text) {
const element = this.elements.get(elementId);
if (element) element.textContent = String(text);
}
setValue(elementId, value) {
const element = this.elements.get(elementId);
if (element && 'value' in element) element.value = value;
}
togglePanel() { this.isOpen ? this.closePanel() : this.openPanel(); }
openPanel() {
this.isOpen = true;
this.elements.get('controlPanel')?.classList.add('open');
this.elements.get('panelOverlay')?.classList.add('active');
this.elements.get('menuToggle')?.classList.add('active');
}
closePanel() {
this.isOpen = false;
this.elements.get('controlPanel')?.classList.remove('open');
this.elements.get('panelOverlay')?.classList.remove('active');
this.elements.get('menuToggle')?.classList.remove('active');
}
hideWelcomeModal() {
const welcomeOverlay = this.elements.get('welcomeOverlay');
if (welcomeOverlay) welcomeOverlay.style.display = 'none';
if (this.onWelcomeComplete) this.onWelcomeComplete();
}
setWelcomeCompleteCallback(callback) { this.onWelcomeComplete = callback; }
updateStats(count) { this.setText('stats', `Points: ${count}`); }
updateButtonState(elementId, isActive, activeText, inactiveText) {
const btn = this.elements.get(elementId);
if (btn) {
btn.classList.toggle('active', isActive);
btn.textContent = isActive ? activeText : inactiveText;
}
}
updateColorControls(useColor) {
['colorControls', 'colorControls2', 'colorButtons', 'colorPreview'].forEach(id => {
const element = this.elements.get(id);
if (element) element.style.display = useColor ? 'block' : 'none';
});
this.updateButtonState('colorModeBtn', !useColor, 'Grayscale', 'Color');
}
updateColorPreview(hue1, hue2) {
const preview = this.elements.get('gradientPreview');
if (preview) {
const color1 = `hsl(${hue1}, 70%, 50%)`;
const color2 = `hsl(${hue2}, 70%, 50%)`;
preview.style.background = `linear-gradient(to right, ${color1}, ${color2})`;
}
this.setText('hue1Value', `${hue1}°`);
this.setText('hue2Value', `${hue2}°`);
}
updateColorValues(hue1, hue2) {
this.setValue('hue1Slider', hue1);
this.setValue('hue2Slider', hue2);
this.updateColorPreview(hue1, hue2);
}
updatePerformanceInfo(level) {
const config = CONFIG.performance.levels[level];
this.setText('performanceValue', config.label);
const width = Math.floor(window.innerWidth / config.skip);
const height = Math.floor(window.innerHeight / config.skip);
const speedup = config.skip === 1 ? '' : ` (${config.skip ** 2}x faster)`;
this.setText('performanceInfo', `Resolution: ${width}×${height}${speedup}`);
}
updatePointList(points) {
const listElement = this.elements.get('pointList');
if (!listElement) return;
if (points.count === 0) {
listElement.innerHTML = '<div class="no-selection">No points created</div>';
return;
}
const pointsArray = points.getAllPoints();
listElement.innerHTML = pointsArray.map(point =>
`<div class="point-item ${point.selected ? 'selected' : ''}" data-id="${point.id}">
${point.getDisplayName()} - ${point.waveType} (${point.strength})${point.velocity > 0 ? ` • v${point.velocity}` : ''}
</div>`
).join('');
}
updateSelectedPoint(point) {
const section = this.elements.get('selectedPointSection');
if (!point) {
if (section) section.style.display = 'none';
return;
}
if (section) section.style.display = 'block';
this.setText('selectedPointId', point.getDisplayName());
this.setText('pointWaveTypeBtn', point.waveType === 'sine' ? 'Sine' : 'Digital');
this.setValue('pointStrengthSlider', point.strength);
this.setValue('pointFrequencySlider', point.frequency);
this.setValue('pointSpeedSlider', point.speed);
this.setValue('pointVelocitySlider', point.velocity);
this.setText('pointStrengthValue', point.strength);
this.setText('pointFrequencyValue', Utils.formatValue(point.frequency));
this.setText('pointSpeedValue', Utils.formatValue(point.speed, 1));
this.setText('pointVelocityValue', point.velocity);
const waveTypeBtn = this.elements.get('pointWaveTypeBtn');
if (waveTypeBtn) {
waveTypeBtn.className = `control-button ${point.waveType === 'sine' ? 'active' : ''}`;
}
}
}

// ===== INTERACTION MANAGER WITH LONG PRESS =====
class InteractionManager {
constructor(canvas) {
this.canvas = canvas;
this.isDragging = false;
this.dragPoint = null;
this.startDragPos = { x: 0, y: 0 };
this.hasMoved = false;

// Long press state
this.longPressTimer = null;
this.longPressPos = { x: 0, y: 0 };
this.isLongPressing = false;
this.indicator = document.getElementById('longPressIndicator');

this.setupEventListeners();
}
setupEventListeners() {
const options = { passive: false };
this.canvas.addEventListener('touchstart', (e) => this.handleStart(e, e.touches[0]), options);
this.canvas.addEventListener('touchmove', (e) => this.handleMove(e, e.touches[0]), options);
this.canvas.addEventListener('touchend', (e) => this.handleEnd(e), options);
this.canvas.addEventListener('mousedown', (e) => this.handleStart(e, e));
this.canvas.addEventListener('mousemove', (e) => this.handleMove(e, e));
this.canvas.addEventListener('mouseup', (e) => this.handleEnd(e));
this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
this.canvas.addEventListener('touchend', (e) => {
if (e.touches.length === 0) e.preventDefault();
});
}
getCoordinates(pointer) {
const rect = this.canvas.getBoundingClientRect();
return {
x: Math.floor(pointer.clientX - rect.left),
y: Math.floor(pointer.clientY - rect.top)
};
}
startLongPress(x, y) {
this.longPressPos = { x, y };
this.isLongPressing = true;

// Show indicator at position
if (this.indicator) {
this.indicator.style.left = x + 'px';
this.indicator.style.top = y + 'px';
this.indicator.classList.remove('complete');
this.indicator.classList.add('active');
}
this.longPressTimer = setTimeout(() => {
if (this.isLongPressing && !this.hasMoved) {
this.completeLongPress();
}
}, CONFIG.interaction.longPressTime);
}
completeLongPress() {
Utils.triggerHaptic();

// Complete animation
if (this.indicator) {
this.indicator.classList.remove('active');
this.indicator.classList.add('complete');
setTimeout(() => {
this.indicator.classList.remove('complete');
}, 300);
}
// Create wave point at position
this.simulation.addWavePoint(this.longPressPos.x, this.longPressPos.y);
this.cancelLongPress();
}
cancelLongPress() {
if (this.longPressTimer) {
clearTimeout(this.longPressTimer);
this.longPressTimer = null;
}
this.isLongPressing = false;
// Hide indicator
if (this.indicator) {
this.indicator.classList.remove('active');
this.indicator.classList.remove('complete');
}
}
handleStart(event, pointer) {
event.preventDefault();
const { x, y } = this.getCoordinates(pointer);
this.startDragPos = { x, y };
this.hasMoved = false;
const hitPoint = this.simulation.points.findPointAt(x, y);
if (hitPoint) {
// Hit a point - select and prepare for dragging
this.simulation.points.select(hitPoint.id);
this.isDragging = true;
this.dragPoint = hitPoint;
this.canvas.style.cursor = 'grabbing';
} else {
// Hit empty space - start long press for creation
this.startLongPress(x, y);
this.simulation.points.deselect();
}
}
handleMove(event, pointer) {
const { x, y } = this.getCoordinates(pointer);
const moveDistance = Utils.distance(x, y, this.startDragPos.x, this.startDragPos.y);
// Check if moved beyond threshold
if (moveDistance > CONFIG.interaction.moveThreshold) {
this.hasMoved = true;
this.cancelLongPress();  // Cancel long press if moving
}
// Handle dragging
if (this.isDragging && this.dragPoint) {
event.preventDefault();
if (moveDistance > CONFIG.interaction.dragThreshold) {
this.dragPoint.x = x;
this.dragPoint.y = y;
this.simulation.render();
}
}
}
handleEnd(event) {
if (this.isDragging) {
event.preventDefault();
this.isDragging = false;
this.dragPoint = null;
this.hasMoved = false;
this.canvas.style.cursor = 'crosshair';
}
this.cancelLongPress();
}
cleanup() {
this.isDragging = false;
this.dragPoint = null;
this.hasMoved = false;
this.canvas.style.cursor = 'crosshair';
this.cancelLongPress();
}
setSimulation(simulation) { this.simulation = simulation; }
}

// ===== ANIMATION ENGINE =====
class AnimationEngine {
constructor(appState, points, renderer) {
this.appState = appState;
this.points = points;
this.renderer = renderer;
this.animationId = null;
}
start() {
this.appState.setAnimating(true);
this.appState.lastFrameTime = performance.now();
this.animate();
}
stop() {
this.appState.setAnimating(false);
if (this.animationId) {
cancelAnimationFrame(this.animationId);
this.animationId = null;
}
}
toggle() {
if (this.appState.isAnimating) {
this.stop();
} else if (this.points.count > 0) {
this.start();
}
}
animate() {
const currentTime = performance.now();
if (this.appState.shouldRender(currentTime)) {
const deltaTime = (currentTime - this.appState.lastFrameTime) / 1000;
if (this.appState.animatePoints) {
const bounds = { width: window.innerWidth, height: window.innerHeight };
this.points.updatePositions(deltaTime, bounds);
}
this.appState.incrementTime();
this.render();
this.appState.updateFrameTime(currentTime);
}
if (this.appState.isAnimating) {
this.animationId = requestAnimationFrame(() => this.animate());
}
}
render() {
const colorSettings = this.appState.getColorSettings();
this.renderer.waveField.render(this.points, this.appState.mediumFade, this.appState.time, colorSettings);
this.renderer.point.render(this.points, this.appState.showPoints);
}
}

// ===== MAIN APPLICATION =====
class WaveSimulation {
constructor() {
this.canvas = document.getElementById('canvas');
this.appState = new AppState();
this.points = new PointManager();
this.ui = new UIController();
this.interaction = new InteractionManager(this.canvas);
this.renderer = {
waveField: new WaveFieldRenderer(this.canvas),
point: new PointRenderer(this.canvas)
};
this.animationEngine = new AnimationEngine(this.appState, this.points, this.renderer);
this.initialize();
}
initialize() {
this.interaction.setSimulation(this);
this.ui.setWelcomeCompleteCallback(() => this.initializeStarterPoint());
this.setupEventHandlers();
this.setupStateListeners();
this.setupWindowEvents();
this.initializeUI();
console.log('Wave simulation initialized with long press support');
}
setupEventHandlers() {
// Animation controls
this.ui.on('clearBtn', 'click', () => this.clearAll());
this.ui.on('playPauseBtn', 'click', () => this.animationEngine.toggle());
this.ui.on('syncBtn', 'click', () => this.syncPoints());
this.ui.on('showPointsBtn', 'click', () => this.appState.setShowPoints(!this.appState.showPoints));
this.ui.on('animatePointsBtn', 'click', () => this.appState.setAnimatePoints(!this.appState.animatePoints));
// Point controls
this.ui.on('pointList', 'click', (e) => this.handlePointListClick(e));
this.ui.on('pointWaveTypeBtn', 'click', () => this.toggleSelectedPointWaveType());
this.ui.on('deletePointBtn', 'click', () => this.deleteSelectedPoint());
// Point property sliders
this.ui.on('pointStrengthSlider', 'input', (e) => this.updateSelectedPointProperty('strength', parseInt(e.target.value)));
this.ui.on('pointFrequencySlider', 'input', (e) => this.updateSelectedPointProperty('frequency', parseFloat(e.target.value)));
this.ui.on('pointSpeedSlider', 'input', (e) => this.updateSelectedPointProperty('speed', parseFloat(e.target.value)));
this.ui.on('pointVelocitySlider', 'input', (e) => this.updateSelectedPointProperty('velocity', parseInt(e.target.value)));
// Medium and color controls
this.ui.on('fadeSlider', 'input', (e) => this.appState.setMediumFade(parseFloat(e.target.value)));
this.ui.on('colorModeBtn', 'click', () => this.appState.setUseColor(!this.appState.useColor));
this.ui.on('hue1Slider', 'input', (e) => this.appState.setHue1(parseInt(e.target.value)));
this.ui.on('hue2Slider', 'input', (e) => this.appState.setHue2(parseInt(e.target.value)));
this.ui.on('complementaryBtn', 'click', () => this.setComplementaryColors());
// Performance controls
this.ui.on('performanceSlider', 'input', (e) => this.appState.setPerformanceLevel(parseInt(e.target.value)));
this.ui.on('fpsSlider', 'input', (e) => this.appState.setFPS(parseInt(e.target.value)));
}
setupStateListeners() {
this.appState.on('isAnimatingChanged', (isAnimating) => {
this.ui.updateButtonState('playPauseBtn', !isAnimating, 'Play', 'Pause');
});
this.appState.on('showPointsChanged', (showPoints) => {
this.ui.updateButtonState('showPointsBtn', showPoints, 'Hide Points', 'Show Points');
this.render();
});
this.appState.on('animatePointsChanged', (animatePoints) => {
this.ui.updateButtonState('animatePointsBtn', animatePoints, 'Stop Movement', 'Animate Points');
});
this.appState.on('performanceLevelChanged', (level) => {
this.renderer.waveField.setPerformanceLevel(level);
this.ui.updatePerformanceInfo(level);
});
this.appState.on('fpsChanged', (fps) => this.ui.setText('fpsValue', `${fps} FPS`));
this.appState.on('mediumFadeChanged', (fade) => {
this.ui.setText('fadeValue', Utils.formatValue(fade));
this.ui.setValue('fadeSlider', fade);
});
this.appState.on('useColorChanged', (useColor) => {
this.ui.updateColorControls(useColor);
this.render();
});
this.appState.on('hue1Changed', (hue1) => {
this.ui.updateColorPreview(hue1, this.appState.hue2);
this.render();
});
this.appState.on('hue2Changed', (hue2) => {
this.ui.updateColorPreview(this.appState.hue1, hue2);
this.render();
});
// Point manager events
this.points.on('pointAdded', () => this.updateUI());
this.points.on('pointRemoved', () => this.updateUI());
this.points.on('pointsCleared', () => this.updateUI());
this.points.on('pointSelected', () => this.updateUI());
this.points.on('pointDeselected', () => this.updateUI());
}
setupWindowEvents() {
window.addEventListener('resize', () => {
this.renderer.waveField.resize();
this.ui.updatePerformanceInfo(this.appState.performanceLevel);
});
document.addEventListener('keydown', (e) => {
if ((e.key === 'Delete' || e.key === 'Backspace') && this.points.getSelected()) {
e.preventDefault();
this.deleteSelectedPoint();
}
});
}
initializeUI() {
this.updateUI();
this.ui.updateColorControls(this.appState.useColor);
this.ui.updateColorValues(this.appState.hue1, this.appState.hue2);
}
initializeStarterPoint() {
const centerX = Math.floor(window.innerWidth / 2);
const centerY = Math.floor(window.innerHeight / 2);
const point = this.points.add(centerX, centerY);
point.setStartTime(0);
this.points.select(point.id);
this.animationEngine.start();
console.log('Starter wave point created');
}
handlePointListClick(e) {
const pointItem = e.target.closest('.point-item');
if (pointItem) {
const pointId = pointItem.dataset.id;
this.points.select(pointId);
}
}
addWavePoint(x, y) {
const point = this.points.add(x, y);
point.setStartTime(this.appState.time);
this.points.select(point.id);
if (!this.appState.isAnimating) this.animationEngine.start();
}
updateSelectedPointProperty(property, value) {
const selected = this.points.getSelected();
if (selected && selected.updateProperty(property, value)) {
this.ui.updateSelectedPoint(selected);
this.ui.updatePointList(this.points);
}
}
toggleSelectedPointWaveType() {
const selected = this.points.getSelected();
if (selected) {
selected.waveType = selected.waveType === 'sine' ? 'step' : 'sine';
this.ui.updateSelectedPoint(selected);
this.ui.updatePointList(this.points);
}
}
    cloneSelectedPoint() {
        const selected = this.points.getSelected();
        if (!selected) return;
        
        // Generate random position with margins
        const margin = 30;
        const maxAttempts = 50;
        let x, y;
        let attempts = 0;
        
        // Try to find a position not too close to existing points
        do {
            x = margin + Math.random() * (window.innerWidth - 2 * margin);
            y = margin + Math.random() * (window.innerHeight - 2 * margin);
            attempts++;
            
            // Check distance from existing points
            let tooClose = false;
            for (const point of this.points) {
                if (Utils.distance(x, y, point.x, point.y) < 40) {
                    tooClose = true;
                    break;
                }
            }
            
            if (!tooClose) break;
        } while (attempts < maxAttempts);
        
        // Create clone with all properties copied
        const clonedPoint = this.points.add(x, y, {
            strength: selected.strength,
            frequency: selected.frequency,
            speed: selected.speed,
            waveType: selected.waveType,
            velocity: selected.velocity
        });
        
        // If original has velocity, give clone a new random direction
        if (selected.velocity > 0) {
            Physics.setRandomVelocity(clonedPoint, selected.velocity);
        }
        
        // Set start time to current time for synchronization
        clonedPoint.setStartTime(this.appState.time);
        
        // Select the new clone
        this.points.select(clonedPoint.id);
        
        // Start animation if not running
        if (!this.appState.isAnimating) this.animationEngine.start();
        
        // Visual feedback - show flash at clone position
        const flash = document.createElement('div');
        flash.className = 'clone-flash';
        flash.style.left = x + 'px';
        flash.style.top = y + 'px';
        document.body.appendChild(flash);
        
        // Remove flash element after animation
        setTimeout(() => flash.remove(), 500);
        
        // Haptic feedback
        Utils.triggerHaptic();
        
        console.log(`Cloned point ${selected.getDisplayName()} to position (${Math.round(x)}, ${Math.round(y)})`);
    }
    deleteSelectedPoint() {
const selected = this.points.getSelected();
if (selected) {
this.points.remove(selected.id);
if (this.points.count === 0) this.animationEngine.stop();
}
}
syncPoints() {
if (this.points.count === 0) return;
this.appState.resetTime();
for (const point of this.points) {
point.setStartTime(0);
}
if (!this.appState.isAnimating) this.animationEngine.start();
console.log(`Synchronized ${this.points.count} wave points`);
}
setComplementaryColors() {
const complementaryHue = (this.appState.hue1 + 180) % 360;
this.appState.setHue2(complementaryHue);
this.ui.updateColorValues(this.appState.hue1, complementaryHue);
}
updateUI() {
this.ui.updateStats(this.points.count);
this.ui.updatePointList(this.points);
this.ui.updateSelectedPoint(this.points.getSelected());
}
render() {
this.animationEngine.render();
}
clearAll() {
this.points.clear();
this.appState.resetTime();
this.appState.setShowPoints(false);
this.animationEngine.stop();
this.interaction.cleanup();
this.render();
}
}

// ===== INITIALIZATION =====
document.addEventListener('DOMContentLoaded', () => {
try {
new WaveSimulation();
} catch (error) {
console.error('Failed to initialize wave simulation:', error);
document.body.innerHTML = `
<div style="display: flex; align-items: center; justify-content: center; height: 100vh; color: white; text-align: center; font-family: monospace;">
<div>
<h2>Wave Simulation Error</h2>
<p>Failed to initialize application</p>
<p style="font-size: 12px; opacity: 0.7;">Check console for details</p>
</div>
</div>
`;
}
});
</script>
</body>
</html>