<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Wave Simulation - Advanced Pattern Editor</title>
<style>
:root {
    /* Colors */
    --color-primary: #00ff88;
    --color-secondary: #0088ff;
    --color-danger: #ff4444;
    --color-warning: #ff8844;
    --color-pattern: #8a2be2;
    
    /* UI Colors */
    --bg-primary: rgba(20, 20, 20, 0.95);
    --bg-secondary: rgba(255, 255, 255, 0.05);
    --bg-button: rgba(255, 255, 255, 0.1);
    --bg-button-hover: rgba(255, 255, 255, 0.2);
    --bg-button-active: rgba(255, 255, 255, 0.3);
    --border-primary: rgba(255, 255, 255, 0.1);
    --border-secondary: rgba(255, 255, 255, 0.2);
    --text-primary: white;
    --text-secondary: rgba(255, 255, 255, 0.7);
    --text-muted: rgba(255, 255, 255, 0.5);
    
    /* Spacing */
    --spacing-xs: 5px;
    --spacing-sm: 10px;
    --spacing-md: 15px;
    --spacing-lg: 20px;
    --spacing-xl: 30px;
    
    /* Sizes */
    --control-height: 44px;
    --slider-height: 6px;
    --thumb-size: 20px;
    --point-radius: 6px;
    --select-radius: 20px;
    
    /* Animation */
    --transition-fast: 0.2s ease;
    --transition-normal: 0.3s ease;
    --transition-slow: 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    overflow: hidden;
    background: #000;
}

/* Canvas */
#canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    cursor: crosshair;
    touch-action: none;
}

/* Visual Indicators */
.visual-indicator {
    position: fixed;
    pointer-events: none;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    z-index: 1000;
}

.long-press-indicator {
    width: 60px;
    height: 60px;
    border: 2px solid rgba(0, 255, 136, 0.6);
}

.long-press-indicator.active {
    animation: longPressGrow 0.5s ease-out forwards;
}

.long-press-indicator.complete {
    animation: fadeOut 0.3s ease-out forwards;
}

.clone-flash {
    width: 80px;
    height: 80px;
    border: 3px solid var(--color-secondary);
    animation: pulseOut 0.5s ease-out;
}

/* Animations */
@keyframes longPressGrow {
    from {
        opacity: 1;
        transform: translate(-50%, -50%) scale(0.5);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
        border-color: var(--color-primary);
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
    }
}

@keyframes fadeOut {
    from {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
    }
    to {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1.5);
    }
}

@keyframes pulseOut {
    0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
    }
    50% {
        opacity: 1;
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(2);
    }
}

/* Menu Toggle */
.menu-toggle {
    position: fixed;
    top: var(--spacing-lg);
    right: var(--spacing-lg);
    z-index: 1000;
    width: 50px;
    height: 50px;
    background: var(--bg-button);
    backdrop-filter: blur(10px);
    border: 1px solid var(--border-secondary);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: var(--transition-normal);
}

.menu-toggle:hover {
    background: var(--bg-button-hover);
}

.menu-icon {
    width: 24px;
    height: 18px;
    position: relative;
}

.menu-icon span {
    display: block;
    width: 100%;
    height: 2px;
    background: var(--text-primary);
    margin: 4px 0;
    transition: var(--transition-normal);
}

.menu-toggle.active .menu-icon span:nth-child(1) {
    transform: rotate(45deg) translate(5px, 5px);
}

.menu-toggle.active .menu-icon span:nth-child(2) {
    opacity: 0;
}

.menu-toggle.active .menu-icon span:nth-child(3) {
    transform: rotate(-45deg) translate(7px, -6px);
}

/* Control Panel */
.control-panel {
    position: fixed;
    top: 0;
    right: -360px;
    width: 360px;
    height: 100vh;
    background: var(--bg-primary);
    backdrop-filter: blur(20px);
    border-left: 1px solid var(--border-primary);
    z-index: 999;
    transition: right var(--transition-slow);
    overflow-y: auto;
    color: var(--text-primary);
}

.control-panel.open {
    right: 0;
}

.panel-header {
    padding: var(--spacing-lg);
    border-bottom: 1px solid var(--border-primary);
}

.panel-title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 5px;
}

.panel-subtitle {
    font-size: 12px;
    opacity: 0.7;
}

.control-section {
    padding: var(--spacing-lg);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.section-title {
    font-size: 14px;
    font-weight: 500;
    margin-bottom: var(--spacing-md);
    opacity: 0.9;
}

.subsection {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: var(--spacing-sm);
    margin-top: var(--spacing-md);
}

.subsection-title {
    font-size: 12px;
    font-weight: 500;
    margin-bottom: var(--spacing-sm);
    opacity: 0.8;
}

/* Form Controls */
.control-group {
    margin-bottom: var(--spacing-lg);
}

.control-group.compact {
    margin-bottom: var(--spacing-sm);
}

.control-label {
    display: block;
    font-size: 12px;
    margin-bottom: 8px;
    opacity: 0.8;
}

.select-input {
    width: 100%;
    padding: 8px;
    background: var(--bg-button);
    border: 1px solid var(--border-secondary);
    border-radius: 6px;
    color: var(--text-primary);
    font-size: 13px;
    cursor: pointer;
    transition: var(--transition-fast);
}

.select-input:hover {
    background: var(--bg-button-hover);
}

.select-input:focus {
    outline: none;
    border-color: var(--color-primary);
}

.slider-container {
    position: relative;
}

.slider {
    width: 100%;
    height: var(--slider-height);
    background: var(--bg-button);
    border-radius: 3px;
    outline: none;
    appearance: none;
    -webkit-appearance: none;
}

.slider.mini {
    height: 4px;
}

.slider::-webkit-slider-thumb {
    appearance: none;
    -webkit-appearance: none;
    width: var(--thumb-size);
    height: var(--thumb-size);
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.slider.mini::-webkit-slider-thumb {
    width: 16px;
    height: 16px;
}

.slider::-moz-range-thumb {
    width: var(--thumb-size);
    height: var(--thumb-size);
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.slider.mini::-moz-range-thumb {
    width: 16px;
    height: 16px;
}

.slider-value {
    position: absolute;
    right: 0;
    top: -25px;
    font-size: 11px;
    background: var(--bg-button);
    padding: 2px 6px;
    border-radius: 3px;
    min-width: 35px;
    text-align: center;
}

.slider-value.inline {
    position: static;
    display: inline-block;
    margin-left: 8px;
}

/* Buttons */
.button-group {
    display: flex;
    gap: var(--spacing-sm);
    flex-wrap: wrap;
}

.control-button {
    flex: 1;
    min-width: 80px;
    padding: 12px 16px;
    background: var(--bg-button);
    border: 1px solid var(--border-secondary);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 13px;
    cursor: pointer;
    transition: var(--transition-fast);
}

.control-button.mini {
    padding: 6px 12px;
    font-size: 12px;
    min-width: 60px;
}

.control-button:hover {
    background: var(--bg-button-hover);
}

.control-button:active {
    transform: scale(0.98);
}

.control-button.active {
    background: var(--bg-button-active);
    border-color: rgba(255, 255, 255, 0.5);
}

/* Button Variants */
.control-button.primary {
    background: rgba(0, 255, 136, 0.2);
    border-color: rgba(0, 255, 136, 0.4);
}

.control-button.primary:hover {
    background: rgba(0, 255, 136, 0.3);
}

.control-button.secondary {
    background: rgba(0, 136, 255, 0.2);
    border-color: rgba(0, 136, 255, 0.4);
}

.control-button.secondary:hover {
    background: rgba(0, 136, 255, 0.3);
}

.control-button.danger {
    background: rgba(255, 68, 68, 0.2);
    border-color: rgba(255, 68, 68, 0.4);
}

.control-button.danger:hover {
    background: rgba(255, 68, 68, 0.3);
}

.control-button.pattern {
    background: rgba(138, 43, 226, 0.2);
    border-color: rgba(138, 43, 226, 0.4);
}

.control-button.pattern:hover {
    background: rgba(138, 43, 226, 0.3);
}

/* Status & Info */
.info-text {
    font-size: 11px;
    opacity: 0.6;
    margin-top: var(--spacing-sm);
}

.stats-text {
    font-size: 10px;
    opacity: 0.5;
    margin-top: 5px;
    font-family: monospace;
}

/* Point Management */
.point-section {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-md);
}

.point-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-md);
}

.point-id {
    font-size: 12px;
    opacity: 0.7;
    font-family: monospace;
}

.point-list {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid var(--border-primary);
    border-radius: 5px;
}

.point-item {
    padding: 8px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    cursor: pointer;
    transition: background var(--transition-fast);
    font-size: 12px;
}

.point-item:hover {
    background: var(--bg-button);
}

.point-item.selected {
    background: var(--bg-button-hover);
}

.empty-state {
    text-align: center;
    opacity: 0.5;
    font-size: 12px;
    padding: var(--spacing-lg);
}

/* Overlays */
.panel-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.3);
    z-index: 998;
    opacity: 0;
    visibility: hidden;
    transition: var(--transition-normal);
}

.panel-overlay.active {
    opacity: 1;
    visibility: visible;
}

/* Welcome Modal */
.welcome-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    z-index: 2000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: var(--spacing-lg);
}

.welcome-modal {
    background: var(--bg-primary);
    backdrop-filter: blur(20px);
    border: 1px solid var(--border-secondary);
    border-radius: 16px;
    max-width: 500px;
    width: 100%;
    color: var(--text-primary);
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
}

.welcome-header {
    padding: var(--spacing-xl) var(--spacing-xl) var(--spacing-lg);
    text-align: center;
    border-bottom: 1px solid var(--border-primary);
}

.welcome-header h2 {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 8px;
}

.welcome-header p {
    font-size: 14px;
    opacity: 0.7;
    margin: 0;
}

.welcome-content {
    padding: 25px var(--spacing-xl);
}

.instruction-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.instruction-item {
    font-size: 14px;
    line-height: 1.5;
    padding: 12px 16px;
    background: var(--bg-secondary);
    border-radius: 8px;
    border-left: 3px solid rgba(255, 255, 255, 0.3);
}

.instruction-item strong {
    color: var(--color-primary);
    font-weight: 600;
}

.welcome-footer {
    padding: var(--spacing-lg) var(--spacing-xl) var(--spacing-xl);
    text-align: center;
}

.welcome-button {
    background: linear-gradient(135deg, var(--color-primary), #00cc6a);
    border: none;
    border-radius: 12px;
    color: white;
    font-size: 16px;
    font-weight: 600;
    padding: 16px 32px;
    cursor: pointer;
    transition: var(--transition-normal);
    box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
}

.welcome-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
}

.welcome-button:active {
    transform: translateY(0);
}

/* Responsive Design */
@media (min-width: 768px) {
    .menu-toggle {
        top: var(--spacing-xl);
        right: var(--spacing-xl);
        width: 60px;
        height: 60px;
    }
    
    .control-panel {
        width: 400px;
        right: -400px;
    }
    
    .control-section {
        padding: 25px;
    }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<!-- Visual Indicators -->
<div class="visual-indicator long-press-indicator" id="longPressIndicator"></div>

<!-- Welcome Modal -->
<div class="welcome-overlay" id="welcomeOverlay">
    <div class="welcome-modal">
        <div class="welcome-header">
            <h2>Wave Physics Simulation</h2>
            <p>Advanced pattern generation & wave control</p>
        </div>
        <div class="welcome-content">
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Create waves:</strong> Press and hold on empty space to add wave sources
                </div>
                <div class="instruction-item">
                    <strong>Generate patterns:</strong> Create mathematical layouts with custom wave properties
                </div>
                <div class="instruction-item">
                    <strong>Global control:</strong> Adjust phase shift and time scale for all waves
                </div>
                <div class="instruction-item">
                    <strong>Fine-tune:</strong> Select and modify individual points after generation
                </div>
            </div>
        </div>
        <div class="welcome-footer">
            <button class="welcome-button" id="welcomeStartBtn">Get Started</button>
        </div>
    </div>
</div>

<!-- Menu Toggle -->
<button class="menu-toggle" id="menuToggle">
    <div class="menu-icon">
        <span></span>
        <span></span>
        <span></span>
    </div>
</button>

<!-- Control Panel -->
<div class="panel-overlay" id="panelOverlay"></div>
<div class="control-panel" id="controlPanel">
    <div class="panel-header">
        <div class="panel-title">Wave Pattern Editor</div>
        <div class="panel-subtitle">Advanced wave interference control</div>
    </div>
    
    <!-- Animation Controls -->
    <div class="control-section">
        <div class="section-title">Animation</div>
        <div class="button-group">
            <button class="control-button" id="clearBtn">Clear All</button>
            <button class="control-button" id="playPauseBtn">Pause</button>
            <button class="control-button" id="syncBtn">Sync</button>
        </div>
        <div class="button-group" style="margin-top: 10px;">
            <button class="control-button" id="showPointsBtn">Show Points</button>
            <button class="control-button" id="animatePointsBtn">Animate Points</button>
        </div>
        <div class="info-text" id="stats">Points: 0</div>
    </div>
    
    <!-- Pattern Generator -->
    <div class="control-section">
        <div class="section-title">Pattern Generator</div>
        
        <div class="control-group">
            <label class="control-label">Pattern Type</label>
            <select id="patternType" class="select-input">
                <option value="grid">Grid</option>
                <option value="radial">Radial</option>
                <option value="spiral">Spiral</option>
                <option value="sunflower">Sunflower</option>
            </select>
        </div>
        
        <div class="control-group">
            <label class="control-label">Point Count</label>
            <div class="slider-container">
                <input type="range" class="slider" id="patternCount" min="4" max="36" step="1" value="16">
                <div class="slider-value" id="patternCountValue">16</div>
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Pattern Scale</label>
            <div class="slider-container">
                <input type="range" class="slider" id="patternScale" min="0.3" max="2.0" step="0.1" value="1.0">
                <div class="slider-value" id="patternScaleValue">1.0×</div>
            </div>
            <div class="info-text" id="scaleInfo">Normal size</div>
        </div>
        
        <!-- Wave Template -->
        <div class="subsection">
            <div class="subsection-title">Wave Template</div>
            
            <div class="control-group compact">
                <label class="control-label">Strength</label>
                <div class="slider-container">
                    <input type="range" class="slider mini" id="templateStrength" min="10" max="100" step="5" value="60">
                    <span class="slider-value inline" id="templateStrengthValue">60</span>
                </div>
            </div>
            
            <div class="control-group compact">
                <label class="control-label">Frequency</label>
                <div class="slider-container">
                    <input type="range" class="slider mini" id="templateFrequency" min="0.005" max="0.08" step="0.005" value="0.02">
                    <span class="slider-value inline" id="templateFrequencyValue">0.020</span>
                </div>
            </div>
            
            <div class="control-group compact">
                <label class="control-label">Speed</label>
                <div class="slider-container">
                    <input type="range" class="slider mini" id="templateSpeed" min="0.1" max="1.0" step="0.1" value="1.0">
                    <span class="slider-value inline" id="templateSpeedValue">1.0</span>
                </div>
            </div>
            
            <div class="control-group compact">
                <label class="control-label">Wave Type</label>
                <div class="button-group">
                    <button class="control-button mini active" id="templateWaveType">Sine</button>
                </div>
            </div>
        </div>
        
        <div class="button-group" style="margin-top: 15px;">
            <button class="control-button pattern" id="generatePatternBtn">Generate Pattern</button>
        </div>
        <div class="info-text">Replaces existing points with pattern</div>
    </div>
    
    <!-- Global Wave Control -->
    <div class="control-section">
        <div class="section-title">Global Wave Control</div>
        
        <div class="control-group">
            <label class="control-label">Phase Shift</label>
            <div class="slider-container">
                <input type="range" class="slider" id="phaseShift" min="-3.14159" max="3.14159" step="0.1" value="0">
                <div class="slider-value" id="phaseShiftValue">0.00</div>
            </div>
            <div class="info-text" id="phaseInfo">0° phase offset</div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Time Scale</label>
            <div class="slider-container">
                <input type="range" class="slider" id="timeScale" min="0.25" max="2.0" step="0.05" value="1.0">
                <div class="slider-value" id="timeScaleValue">1.0×</div>
            </div>
            <div class="info-text" id="timeInfo">Normal speed</div>
        </div>
        
        <div class="button-group">
            <button class="control-button" id="resetGlobalBtn">Reset Global</button>
        </div>
    </div>
    
    <!-- Point List -->
    <div class="control-section">
        <div class="section-title">Point List</div>
        <div class="point-list" id="pointList">
            <div class="empty-state">No points created</div>
        </div>
    </div>
    
    <!-- Selected Point Controls -->
    <div class="control-section" id="selectedPointSection" style="display: none;">
        <div class="section-title">Selected Point</div>
        <div class="point-section">
            <div class="point-header">
                <span class="point-id" id="selectedPointId">Point #1</span>
            </div>
            
            <div class="control-group">
                <label class="control-label">Wave Type</label>
                <div class="button-group">
                    <button class="control-button active" id="pointWaveTypeBtn">Sine</button>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Strength</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointStrength" min="10" max="100" step="5" value="60">
                    <div class="slider-value" id="pointStrengthValue">60</div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Frequency</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointFrequency" min="0.005" max="0.08" step="0.005" value="0.02">
                    <div class="slider-value" id="pointFrequencyValue">0.020</div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Speed</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointSpeed" min="0.1" max="1.0" step="0.1" value="1.0">
                    <div class="slider-value" id="pointSpeedValue">1.0</div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Velocity</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointVelocity" min="0" max="50" step="5" value="0">
                    <div class="slider-value" id="pointVelocityValue">0</div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="control-button secondary" id="clonePointBtn">Clone Point</button>
                <button class="control-button danger" id="deletePointBtn">Delete Point</button>
            </div>
        </div>
    </div>
    
    <!-- Medium Properties -->
    <div class="control-section">
        <div class="section-title">Medium Properties</div>
        <div class="control-group">
            <label class="control-label">Wave Fade</label>
            <div class="slider-container">
                <input type="range" class="slider" id="fadeSlider" min="0.0" max="0.03" step="0.002" value="0.008">
                <div class="slider-value" id="fadeValue">0.008</div>
            </div>
        </div>
    </div>
    
    <!-- Color Settings -->
    <div class="control-section">
        <div class="section-title">Color Settings</div>
        <div class="control-group">
            <label class="control-label">Color Mode</label>
            <div class="button-group">
                <button class="control-button active" id="colorModeBtn">Grayscale</button>
            </div>
        </div>
        
        <div class="control-group" id="colorControls" style="display: none;">
            <label class="control-label">Minima Color (Hue)</label>
            <div class="slider-container">
                <input type="range" class="slider" id="hue1Slider" min="0" max="360" step="1" value="240">
                <div class="slider-value" id="hue1Value">240°</div>
            </div>
        </div>
        
        <div class="control-group" id="colorControls2" style="display: none;">
            <label class="control-label">Maxima Color (Hue)</label>
            <div class="slider-container">
                <input type="range" class="slider" id="hue2Slider" min="0" max="360" step="1" value="0">
                <div class="slider-value" id="hue2Value">0°</div>
            </div>
        </div>
        
        <div class="button-group" id="colorButtons" style="display: none;">
            <button class="control-button" id="complementaryBtn">Complementary</button>
        </div>
        
        <div class="control-group" id="colorPreview" style="display: none;">
            <label class="control-label">Color Preview</label>
            <div id="gradientPreview" style="width: 100%; height: 20px; border-radius: 4px; background: linear-gradient(to right, hsl(240, 70%, 50%), hsl(0, 70%, 50%)); border: 1px solid rgba(255, 255, 255, 0.2);"></div>
        </div>
    </div>
    
    <!-- Performance Settings -->
    <div class="control-section">
        <div class="section-title">Performance</div>
        <div class="control-group">
            <label class="control-label">Resolution</label>
            <div class="slider-container">
                <input type="range" class="slider" id="performanceSlider" min="0" max="5" step="1" value="1">
                <div class="slider-value" id="performanceValue">Balanced</div>
            </div>
            <div class="stats-text" id="performanceInfo">Resolution: calculating...</div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Frame Rate</label>
            <div class="slider-container">
                <input type="range" class="slider" id="fpsSlider" min="15" max="60" step="15" value="30">
                <div class="slider-value" id="fpsValue">30 FPS</div>
            </div>
        </div>
    </div>
</div>

<script>

'use strict';

// ===== CONFIGURATION =====
const CONFIG = Object.freeze({
    wave: {
        maxAmplitude: 100,
        timeStep: 0.2,
        defaults: {
            strength: 60,
            frequency: 0.02,
            speed: 1.0,
            waveType: 'sine',
            velocity: 0
        }
    },
    performance: {
        levels: [
            { skip: 1, label: 'Quality' },
            { skip: 2, label: 'Balanced' },
            { skip: 4, label: 'Fast' },
            { skip: 8, label: 'Faster' },
            { skip: 16, label: 'Very Fast' },
            { skip: 32, label: 'Ultra Fast' }
        ],
        default: 1
    },
    colors: {
        hue1: 240,
        hue2: 0,
        saturation: 70,
        lightness: 50,
        useColor: false
    },
    medium: {
        fade: 0.008
    },
    interaction: {
        pointRadius: 20,
        visualRadius: 6,
        dragThreshold: 5,
        longPressTime: 500,
        moveThreshold: 10,
        cloneMargin: 30,
        cloneMinDistance: 40,
        patternMargin: 50
    },
    animation: {
        targetFPS: 30,
        minFPS: 15,
        maxFPS: 60
    },
    ui: {
        sliders: {
            pointStrength: { min: 10, max: 100, step: 5, decimals: 0 },
            pointFrequency: { min: 0.005, max: 0.08, step: 0.005, decimals: 3 },
            pointSpeed: { min: 0.1, max: 1.0, step: 0.1, decimals: 1 },
            pointVelocity: { min: 0, max: 50, step: 5, decimals: 0 }
        }
    }
});

// ===== UTILITIES MODULE =====
const Utils = {
    math: {
        clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
        distance: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
        formatValue: (val, decimals = 3) => Number(val).toFixed(decimals),
        radToDeg: (rad) => (rad * 180 / Math.PI).toFixed(0),
        degToRad: (deg) => deg * Math.PI / 180
    },
    
    id: {
        generate: () => `point_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    },
    
    feedback: {
        haptic: () => {
            if ('vibrate' in navigator) {
                navigator.vibrate(10);
            }
        },
        
        visual: (x, y, className, duration = 500) => {
            const element = document.createElement('div');
            element.className = `visual-indicator ${className}`;
            element.style.left = `${x}px`;
            element.style.top = `${y}px`;
            document.body.appendChild(element);
            setTimeout(() => element.remove(), duration);
            return element;
        }
    },
    
    color: {
        lerpHue: (hue1, hue2, t) => {
            let diff = Math.abs(hue1 - hue2);
            if (diff > 180) {
                if (hue2 > hue1) hue1 += 360;
                else hue2 += 360;
            }
            return Math.round((hue1 + (hue2 - hue1) * t) % 360);
        },
        
        hslToRgb: (h, s, l) => {
            h /= 360;
            s /= 100;
            l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h * 6) % 2 - 1));
            const m = l - c / 2;
            
            let r, g, b;
            if (h < 1/6) [r, g, b] = [c, x, 0];
            else if (h < 2/6) [r, g, b] = [x, c, 0];
            else if (h < 3/6) [r, g, b] = [0, c, x];
            else if (h < 4/6) [r, g, b] = [0, x, c];
            else if (h < 5/6) [r, g, b] = [x, 0, c];
            else [r, g, b] = [c, 0, x];
            
            return {
                r: Math.round((r + m) * 255),
                g: Math.round((g + m) * 255),
                b: Math.round((b + m) * 255)
            };
        }
    },
    
    storage: {
        save: (key, value) => {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.warn('Failed to save to localStorage:', e);
            }
        },
        
        load: (key, defaultValue = null) => {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : defaultValue;
            } catch (e) {
                console.warn('Failed to load from localStorage:', e);
                return defaultValue;
            }
        }
    }
};

// ===== BASE CLASSES =====
class EventEmitter {
    constructor() {
        this.listeners = new Map();
    }
    
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
        return this;
    }
    
    emit(event, data) {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            callbacks.forEach(cb => cb(data));
        }
        return this;
    }
}

// ===== PHYSICS MODULE =====
const Physics = {
    updatePosition(point, deltaTime, bounds) {
        if (point.velocity === 0) return;
        
        point.x += point.vx * deltaTime;
        point.y += point.vy * deltaTime;
        
        const margin = CONFIG.interaction.visualRadius;
        
        // Boundary collision
        if (point.x <= margin || point.x >= bounds.width - margin) {
            point.vx = point.x <= margin ? Math.abs(point.vx) : -Math.abs(point.vx);
            point.x = Utils.math.clamp(point.x, margin, bounds.width - margin);
        }
        
        if (point.y <= margin || point.y >= bounds.height - margin) {
            point.vy = point.y <= margin ? Math.abs(point.vy) : -Math.abs(point.vy);
            point.y = Utils.math.clamp(point.y, margin, bounds.height - margin);
        }
    },
    
    setRandomVelocity(point, speed) {
        if (speed > 0) {
            const angle = Math.random() * 2 * Math.PI;
            point.vx = Math.cos(angle) * speed;
            point.vy = Math.sin(angle) * speed;
        } else {
            point.vx = point.vy = 0;
        }
    },
    
    findRandomPosition(points, bounds) {
        const { cloneMargin: margin, cloneMinDistance: minDist } = CONFIG.interaction;
        const maxAttempts = 50;
        
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const x = margin + Math.random() * (bounds.width - 2 * margin);
            const y = margin + Math.random() * (bounds.height - 2 * margin);
            
            const tooClose = Array.from(points).some(point => 
                Utils.math.distance(x, y, point.x, point.y) < minDist
            );
            
            if (!tooClose) return { x, y };
        }
        
        return {
            x: margin + Math.random() * (bounds.width - 2 * margin),
            y: margin + Math.random() * (bounds.height - 2 * margin)
        };
    }
};

// ===== WAVE MATHEMATICS =====
const WaveMath = {
    sine: (phase, amplitude) => amplitude * Math.sin(phase),
    
    step: (phase, amplitude) => {
        const normalized = ((phase % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
        return amplitude * (normalized < Math.PI ? 1 : -1);
    },
    
    applyFade: (value, distance, fadeRate) => value * Math.exp(-distance * fadeRate),
    
    toColor(waveValue, colorSettings) {
        if (!colorSettings.useColor) {
            const normalized = waveValue / CONFIG.wave.maxAmplitude;
            return Utils.math.clamp(128 + normalized * 127, 0, 255);
        }
        
        const normalizedValue = Utils.math.clamp(
            (waveValue / CONFIG.wave.maxAmplitude + 1) / 2, 0, 1
        );
        const interpolatedHue = Utils.color.lerpHue(
            colorSettings.hue1, colorSettings.hue2, normalizedValue
        );
        return Utils.color.hslToRgb(
            interpolatedHue, colorSettings.saturation, colorSettings.lightness
        );
    }
};

// ===== PATTERN GENERATOR =====
const PatternGenerator = {
    patterns: {
        grid(count, cx, cy, maxRadius, scale) {
            const points = [];
            const gridSize = Math.ceil(Math.sqrt(count));
            const spacing = (maxRadius * 2 / (gridSize + 1)) * scale;
            const startX = cx - (gridSize - 1) * spacing / 2;
            const startY = cy - (gridSize - 1) * spacing / 2;
            
            for (let i = 0; i < gridSize * gridSize && points.length < count; i++) {
                const row = Math.floor(i / gridSize);
                const col = i % gridSize;
                points.push({
                    x: startX + col * spacing,
                    y: startY + row * spacing
                });
            }
            return points;
        },
        
        radial(count, cx, cy, maxRadius, scale) {
            const points = [];
            const rings = Math.min(4, Math.ceil(count / 8));
            const pointsPerRing = Math.ceil(count / rings);
            
            for (let ring = 0; ring < rings; ring++) {
                const radius = ((ring + 1) / rings) * maxRadius * scale;
                const ringCount = Math.min(pointsPerRing, count - points.length);
                
                for (let i = 0; i < ringCount; i++) {
                    const angle = (i / ringCount) * 2 * Math.PI - Math.PI / 2;
                    points.push({
                        x: cx + radius * Math.cos(angle),
                        y: cy + radius * Math.sin(angle)
                    });
                }
            }
            return points;
        },
        
        spiral(count, cx, cy, maxRadius, scale) {
            const points = [];
            const maxAngle = 4 * Math.PI;
            
            for (let i = 0; i < count; i++) {
                const t = (i / count) * maxAngle;
                const radius = (t / maxAngle) * maxRadius * scale;
                points.push({
                    x: cx + radius * Math.cos(t),
                    y: cy + radius * Math.sin(t)
                });
            }
            return points;
        },
        
        sunflower(count, cx, cy, maxRadius, scale) {
            const points = [];
            const golden = Math.PI * (3 - Math.sqrt(5));
            
            for (let i = 0; i < count; i++) {
                const theta = i * golden;
                const radius = Math.sqrt(i / count) * maxRadius * scale;
                points.push({
                    x: cx + radius * Math.cos(theta),
                    y: cy + radius * Math.sin(theta)
                });
            }
            return points;
        }
    },
    
    generate(type, count, bounds, scale = 1.0) {
        const cx = bounds.width / 2;
        const cy = bounds.height / 2;
        const maxRadius = Math.min(bounds.width, bounds.height) / 2 - CONFIG.interaction.patternMargin;
        
        const generator = this.patterns[type];
        return generator ? generator(count, cx, cy, maxRadius, scale) : [];
    }
};

// ===== WAVE POINT =====
class WavePoint {
    constructor(x, y, properties = {}) {
        this.id = Utils.id.generate();
        this.x = x;
        this.y = y;
        this.startTime = 0;
        this.selected = false;
        this.vx = 0;
        this.vy = 0;
        
        Object.assign(this, CONFIG.wave.defaults, properties);
        
        if (this.velocity > 0) {
            Physics.setRandomVelocity(this, this.velocity);
        }
    }
    
    getProperties() {
        return {
            strength: this.strength,
            frequency: this.frequency,
            speed: this.speed,
            waveType: this.waveType,
            velocity: this.velocity
        };
    }
    
    updateVelocity(newVelocity) {
        const oldVelocity = this.velocity;
        this.velocity = newVelocity;
        
        if (newVelocity === 0) {
            this.vx = this.vy = 0;
        } else if (oldVelocity === 0) {
            Physics.setRandomVelocity(this, newVelocity);
        } else {
            const scale = newVelocity / oldVelocity;
            this.vx *= scale;
            this.vy *= scale;
        }
    }
    
    updateProperty(key, value) {
        if (key === 'velocity') {
            this.updateVelocity(value);
        } else if (key in CONFIG.wave.defaults) {
            this[key] = value;
        } else {
            return false;
        }
        return true;
    }
    
    distanceTo(x, y) {
        return Utils.math.distance(this.x, this.y, x, y);
    }
    
    isHit(x, y) {
        return this.distanceTo(x, y) <= CONFIG.interaction.pointRadius;
    }
    
    getDisplayName() {
        return `Point ${this.id.split('_')[1].slice(-3)}`;
    }
}

// ===== MANAGERS =====
class PointManager extends EventEmitter {
    constructor() {
        super();
        this.points = new Map();
        this.selectedId = null;
    }
    
    add(x, y, properties = {}) {
        const point = new WavePoint(x, y, properties);
        this.points.set(point.id, point);
        this.emit('change', { type: 'add', point });
        return point;
    }
    
    remove(id) {
        if (this.selectedId === id) this.selectedId = null;
        const removed = this.points.delete(id);
        if (removed) this.emit('change', { type: 'remove', id });
        return removed;
    }
    
    clear() {
        this.points.clear();
        this.selectedId = null;
        this.emit('change', { type: 'clear' });
    }
    
    select(id) {
        const prevId = this.selectedId;
        if (prevId) {
            const prev = this.points.get(prevId);
            if (prev) prev.selected = false;
        }
        
        this.selectedId = id;
        const point = this.points.get(id);
        if (point) {
            point.selected = true;
            this.emit('select', point);
        }
        return point;
    }
    
    deselect() {
        if (this.selectedId) {
            const point = this.points.get(this.selectedId);
            if (point) point.selected = false;
            this.selectedId = null;
            this.emit('select', null);
        }
    }
    
    getSelected() {
        return this.selectedId ? this.points.get(this.selectedId) : null;
    }
    
    findPointAt(x, y) {
        for (const point of this.points.values()) {
            if (point.isHit(x, y)) return point;
        }
        return null;
    }
    
    updatePositions(deltaTime, bounds) {
        for (const point of this.points.values()) {
            Physics.updatePosition(point, deltaTime, bounds);
        }
    }
    
    getAllPoints() {
        return Array.from(this.points.values());
    }
    
    get count() {
        return this.points.size;
    }
    
    [Symbol.iterator]() {
        return this.points.values();
    }
}

class AppState extends EventEmitter {
    constructor() {
        super();
        
        // Load saved template or use defaults
        const savedTemplate = Utils.storage.load('waveTemplate', CONFIG.wave.defaults);
        
        this.state = {
            time: 0,
            isAnimating: false,
            showPoints: false,
            animatePoints: false,
            mediumFade: CONFIG.medium.fade,
            performanceLevel: CONFIG.performance.default,
            phaseShift: 0,
            timeScale: 1.0,
            patternScale: 1.0,
            patternTemplate: savedTemplate,
            ...CONFIG.colors
        };
        
        this.animation = {
            targetFPS: CONFIG.animation.targetFPS,
            frameInterval: 1000 / CONFIG.animation.targetFPS,
            lastFrameTime: 0
        };
    }
    
    set(key, value) {
        if (this.state[key] !== value) {
            this.state[key] = value;
            this.emit('change', { key, value });
            
            // Save template when it changes
            if (key === 'patternTemplate') {
                Utils.storage.save('waveTemplate', value);
            }
        }
    }
    
    get(key) {
        return this.state[key];
    }
    
    setTemplate(properties) {
        this.set('patternTemplate', { ...this.state.patternTemplate, ...properties });
    }
    
    setFPS(fps) {
        this.animation.targetFPS = Utils.math.clamp(
            fps, CONFIG.animation.minFPS, CONFIG.animation.maxFPS
        );
        this.animation.frameInterval = 1000 / this.animation.targetFPS;
        this.emit('change', { key: 'fps', value: this.animation.targetFPS });
    }
    
    incrementTime() {
        // Apply time scale to time increment
        this.state.time += CONFIG.wave.timeStep * this.state.timeScale;
    }
    
    resetTime() {
        this.state.time = 0;
    }
    
    shouldRender(currentTime) {
        return this.state.isAnimating && 
               (currentTime - this.animation.lastFrameTime) >= this.animation.frameInterval;
    }
    
    getColorSettings() {
        return {
            useColor: this.state.useColor,
            hue1: this.state.hue1,
            hue2: this.state.hue2,
            saturation: this.state.saturation,
            lightness: this.state.lightness
        };
    }
}

// ===== RENDERERS =====
class WaveFieldRenderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.skipFactor = CONFIG.performance.levels[CONFIG.performance.default].skip;
        this.resize();
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
    }
    
    setPerformanceLevel(level) {
        this.skipFactor = CONFIG.performance.levels[level].skip;
    }
    
    render(points, mediumFade, time, phaseShift, colorSettings) {
        this.clearCanvas();
        if (points.count > 0) {
            this.renderWaveField(points, mediumFade, time, phaseShift, colorSettings);
        }
        this.ctx.putImageData(this.imageData, 0, 0);
    }
    
    clearCanvas() {
        const data = this.imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i + 1] = data[i + 2] = 0;
            data[i + 3] = 255;
        }
    }
    
    renderWaveField(points, mediumFade, time, phaseShift, colorSettings) {
        const { width, height } = this.canvas;
        const skip = this.skipFactor;
        
        for (let y = 0; y < height; y += skip) {
            for (let x = 0; x < width; x += skip) {
                const color = this.calculatePixel(x, y, points, mediumFade, time, phaseShift, colorSettings);
                this.fillBlock(x, y, color, skip);
            }
        }
    }
    
    calculatePixel(x, y, points, mediumFade, time, phaseShift, colorSettings) {
        let totalWave = 0;
        
        for (const point of points) {
            const age = time - point.startTime;
            if (age < 0) continue;
            
            const distance = point.distanceTo(x, y);
            // Apply phase shift to the wave calculation
            const phase = point.frequency * distance - point.speed * age + phaseShift;
            
            const waveFunc = point.waveType === 'sine' ? WaveMath.sine : WaveMath.step;
            let waveValue = waveFunc(phase, point.strength);
            waveValue = WaveMath.applyFade(waveValue, distance, mediumFade);
            
            totalWave += waveValue;
        }
        
        return WaveMath.toColor(totalWave, colorSettings);
    }
    
    fillBlock(startX, startY, color, size) {
        const data = this.imageData.data;
        const { width, height } = this.canvas;
        
        for (let dy = 0; dy < size && startY + dy < height; dy++) {
            for (let dx = 0; dx < size && startX + dx < width; dx++) {
                const index = ((startY + dy) * width + (startX + dx)) * 4;
                
                if (typeof color === 'object') {
                    data[index] = color.r;
                    data[index + 1] = color.g;
                    data[index + 2] = color.b;
                } else {
                    data[index] = data[index + 1] = data[index + 2] = color;
                }
            }
        }
    }
}

class PointRenderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
    }
    
    render(points, showPoints) {
        const selected = points.getSelected();
        
        if (showPoints) {
            for (const point of points) {
                this.drawPoint(point);
            }
        } else if (selected) {
            this.drawPoint(selected);
        }
    }
    
    drawPoint(point) {
        const { visualRadius, pointRadius } = CONFIG.interaction;
        
        if (point.selected) {
            this.ctx.strokeStyle = '#00ff88';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, pointRadius, 0, 2 * Math.PI);
            this.ctx.stroke();
        }
        
        this.ctx.fillStyle = point.selected ? '#00ff88' : 
                             point.velocity > 0 ? '#ff8844' : '#ff4444';
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, visualRadius, 0, 2 * Math.PI);
        this.ctx.fill();
    }
}

// ===== UI CONTROLLER =====
class UIController {
    constructor() {
        this.elements = new Map();
        this.panelOpen = false;
        this.init();
    }
    
    init() {
        this.cacheElements();
        this.setupBaseEvents();
    }
    
    cacheElements() {
        const ids = [
            // Core elements
            'menuToggle', 'panelOverlay', 'controlPanel', 'welcomeOverlay', 'welcomeStartBtn',
            // Animation controls
            'clearBtn', 'playPauseBtn', 'syncBtn', 'showPointsBtn', 'animatePointsBtn', 'stats',
            // Pattern generator
            'patternType', 'patternCount', 'patternCountValue', 'patternScale', 'patternScaleValue',
            'scaleInfo', 'generatePatternBtn',
            // Wave template
            'templateStrength', 'templateStrengthValue', 'templateFrequency', 'templateFrequencyValue',
            'templateSpeed', 'templateSpeedValue', 'templateWaveType',
            // Global wave control
            'phaseShift', 'phaseShiftValue', 'phaseInfo', 'timeScale', 'timeScaleValue', 'timeInfo',
            'resetGlobalBtn',
            // Point list
            'pointList', 'selectedPointSection', 'selectedPointId', 'pointWaveTypeBtn',
            'pointStrength', 'pointFrequency', 'pointSpeed', 'pointVelocity',
            'clonePointBtn', 'deletePointBtn',
            // Medium and color
            'fadeSlider', 'fadeValue', 'colorModeBtn', 
            'hue1Slider', 'hue2Slider', 'hue1Value', 'hue2Value',
            'complementaryBtn', 'gradientPreview', 'colorControls', 'colorControls2',
            'colorButtons', 'colorPreview',
            // Performance
            'performanceSlider', 'performanceValue', 'performanceInfo', 
            'fpsSlider', 'fpsValue',
            // Other
            'longPressIndicator'
        ];
        
        // Add value display elements for point controls
        Object.keys(CONFIG.ui.sliders).forEach(key => {
            ids.push(`${key}Value`);
        });
        
        ids.forEach(id => {
            const element = document.getElementById(id);
            if (element) this.elements.set(id, element);
        });
    }
    
    setupBaseEvents() {
        this.on('menuToggle', 'click', () => this.togglePanel());
        this.on('panelOverlay', 'click', () => this.closePanel());
        this.on('welcomeStartBtn', 'click', () => this.hideWelcome());
        
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape' && this.panelOpen) {
                this.closePanel();
            }
        });
    }
    
    on(elementId, event, handler) {
        const element = this.elements.get(elementId);
        if (element) {
            element.addEventListener(event, handler);
        }
    }
    
    get(elementId) {
        return this.elements.get(elementId);
    }
    
    setText(elementId, text) {
        const element = this.elements.get(elementId);
        if (element) element.textContent = String(text);
    }
    
    setValue(elementId, value) {
        const element = this.elements.get(elementId);

</script>
</body>
</html>